// FILE: api/src/jobs/sla.ts
/**
 * Sprint 5 – SLA checker (BullMQ + ioredis).
 * - scheduleSlaCheck(): adds a repeating job (every minute)
 * - startSlaWorker(): processes the job, finds overdue incidents, emails/logs summary
 */
import { Queue, Worker, JobsOptions } from "bullmq";
import IORedis from "ioredis";
import nodemailer from "nodemailer";
import { prisma } from "../db";

// ---- minimal config from env (no extra config file required) ----
const redisUrl   = process.env.REDIS_URL   ?? "redis://127.0.0.1:6379";
const smtpUrl    = process.env.SMTP_URL    ?? ""; // if empty, use jsonTransport (logs only)
const emailTo    = process.env.SLA_EMAIL_TO   ?? "ops@example.com";
const emailFrom  = process.env.SLA_EMAIL_FROM ?? "noreply@example.com";

// Shared Redis connection for queue+worker
const connection = new IORedis(redisUrl, { maxRetriesPerRequest: null });

// Queue name
const QUEUE = "sla-check";

// Create queue
const slaQueue = new Queue(QUEUE, { connection });

// Utility: transport that always works in dev
const transporter: nodemailer.Transporter = smtpUrl
  ? nodemailer.createTransport(smtpUrl)
  : nodemailer.createTransport({ jsonTransport: true });

// Business rule: “older than X hours if not resolved/closed”
const HOURS = { CRITICAL: 2, HIGH: 6, MEDIUM: 24, LOW: 48 } as const;

function isOverdue(priority: keyof typeof HOURS, createdAt: Date): boolean {
  const ms = HOURS[priority] * 60 * 60 * 1000;
  return Date.now() - createdAt.getTime() > ms;
}

/**
 * Add a repeating job every minute (idempotent).
 */
export async function scheduleSlaCheck() {
  const opts: JobsOptions = {
    repeat: { every: 60_000 }, // 1m
    jobId: "sla:repeat",       // so we don’t create duplicates
    removeOnComplete: true,
    removeOnFail: true,
  };
  await slaQueue.add("tick", {}, opts);
}

/**
 * Start worker to process SLA jobs.
 */
export function startSlaWorker() {
  // eslint-disable-next-line no-new
  new Worker(
    QUEUE,
    async () => {
      // Fetch non-closed incidents and filter by per-priority thresholds
      const openish = await prisma.incident.findMany({
        where: { status: { notIn: ["RESOLVED", "CLOSED"] } },
        select: { id: true, title: true, priority: true, createdAt: true },
      });

      const overdue = openish.filter(i =>
        isOverdue(i.priority as keyof typeof HOURS, i.createdAt)
      );

      if (overdue.length === 0) return;

      // Build message
      const lines = overdue.map(
        i => `#${i.id} [${i.priority}] ${i.title} — opened ${i.createdAt.toISOString()}`
      );
      const subject = `[SLA] ${overdue.length} incident(s) overdue`;
      const text = lines.join("\n");

      // Send (or log) message
      await transporter.sendMail({
        from: emailFrom,
        to: emailTo,
        subject,
        text,
      });
      console.log(`SLA email queued: ${subject}`);
    },
    { connection }
  );
}
